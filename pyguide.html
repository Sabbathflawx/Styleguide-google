<HTML xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcq="http://purl.org/dc/qualifiers/1.0/" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:fn="http://www.w3.org/2005/xpath-functions">
<HEAD>
<TITLE>Google Python 代码风格指南</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK HREF="http://www.google.com/favicon.ico" type="image/x-icon" rel="shortcut icon">
<LINK HREF="styleguide.css" type="text/css" rel="stylesheet">
<SCRIPT language="javascript" type="text/javascript">

                function GetElementsByName(name) {
                  // Workaround a bug on old versions of opera.
                  if (document.getElementsByName) {
                    return document.getElementsByName(name);
                  } else {
                    return [document.getElementById(name)];
                  }
                }

                /**
                 * @param {string} namePrefix The prefix of the body name.
                 * @param {function(boolean): boolean} getVisibility Computes the new
                 *     visibility state, given the current one.
                 */
                function ChangeVisibility(namePrefix, getVisibility) {
                  var bodyName = namePrefix + '__body';
                  var buttonName = namePrefix + '__button';
                  var bodyElements = GetElementsByName(bodyName);
                  var linkElement = GetElementsByName('link-' + buttonName)[0];
                  if (bodyElements.length != 1) {
                    throw Error('ShowHideByName() got the wrong number of bodyElements:  ' + 
                        bodyElements.length);
                  } else {
                    var bodyElement = bodyElements[0];
                    var buttonElement = GetElementsByName(buttonName)[0];
                    var isVisible = bodyElement.style.display != "none";
                    if (getVisibility(isVisible)) {
                      bodyElement.style.display = "inline";
                      linkElement.style.display = "block";
                      buttonElement.innerHTML = '▽';
                    } else {
                      bodyElement.style.display = "none";
                      linkElement.style.display = "none";
                      buttonElement.innerHTML = '▶';
                    }
                  }
                }

                function ShowHideByName(namePrefix) {
                  ChangeVisibility(namePrefix, function(old) { return !old; });
                }

                function ShowByName(namePrefix) {
                  ChangeVisibility(namePrefix, function() { return true; });
                }

                function ShowHideAll() {
                  var allButton = GetElementsByName("show_hide_all_button")[0];
                  if (allButton.innerHTML == '▽') {
                    allButton.innerHTML = '▶';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "none", '▶');
                  } else {
                    allButton.innerHTML = '▽';
                    SetHiddenState(document.getElementsByTagName("body")[0].childNodes, "inline", '▽');
                  }
                }

                // Recursively sets state of all children
                // of a particular node.
                function SetHiddenState(root, newState, newButton) {
                  for (var i = 0; i != root.length; i++) {
                    SetHiddenState(root[i].childNodes, newState, newButton);
                    if (root[i].className == 'showhide_button')  {
                      root[i].innerHTML = newButton;
                    }
                    if (root[i].className == 'stylepoint_body' ||
                        root[i].className == 'link_button')  {
                      root[i].style.display = newState;
                    }
                  }
                }


                function EndsWith(str, suffix) {
                  var l = str.length - suffix.length;
                  return l >= 0 && str.indexOf(suffix, l) == l;
                }

                function RefreshVisibilityFromHashParam() {
                  var hashRegexp = new RegExp('#([^&#]*)$');
                  var hashMatch = hashRegexp.exec(window.location.href);
                  var anchor = hashMatch && GetElementsByName(hashMatch[1])[0];
                  var node = anchor;
                  var suffix = '__body';
                  while (node) {
                    var id = node.id;
                    var matched = id && EndsWith(id, suffix);
                    if (matched) {
                      var len = id.length - suffix.length;
                      ShowByName(id.substring(0, len));
                      if (anchor.scrollIntoView) {
                        anchor.scrollIntoView();
                      }

                      return;
                    }
                    node = node.parentNode;
                  }
                }

                window.onhashchange = RefreshVisibilityFromHashParam;

                window.onload = function() {
                  // if the URL contains "?showall=y", expand the details of all children
                  var showHideAllRegex = new RegExp("[\\?&](showall)=([^&#]*)");
                  var showHideAllValue = showHideAllRegex.exec(window.location.href);
                  if (showHideAllValue != null) {
                    if (showHideAllValue[2] == "y") {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "inline", '▽');
                    } else {
                      SetHiddenState(document.getElementsByTagName("body")[0].childNodes, 
                          "none", '▶');
                    }
                  }
                  var showOneRegex = new RegExp("[\\?&](showone)=([^&#]*)");
                  var showOneValue = showOneRegex.exec(window.location.href);
                  if (showOneValue) {
                    ShowHideByName(showOneValue[2]);
                  }


                  RefreshVisibilityFromHashParam();
                }
              </SCRIPT>
</HEAD>
<BODY>
<H1>Google Python 代码风格指南</H1>
  <p align="right">

    版本 2.59<br/>
    <a href="http://google.github.io/styleguide/pyguide.html">英文原版</a>
  </p>
  
  <address>
    Amit Patel<br>
    Antoine Picard<br>
    Eugene Jhong<br>
    Jeremy Hylton<br>
    Matt Smart<br>
    Mike Shields<br>
  </address>
  <DIV style="text-align: right; font-size: 75%;">
<P>
		通过点击箭头按钮<SPAN class="showhide_button" style="margin-left: 0; float: none">▶</SPAN>来展开或折叠一个摘要的更多信息<br/>
		您也可以使用大的箭头按钮来展开全部/折叠全部：
      </P>
<DIV style=" font-size: larger; margin-left: +2em;">
<SPAN class="showhide_button" style="font-size: 180%; float: none" onclick="javascript:ShowHideAll()" name="show_hide_all_button" id="show_hide_all_button">▶</SPAN>
        展开/折叠全部
      </DIV>
</DIV>
<DIV class="toc">
<DIV class="toc_title">内容列表</DIV>
<TABLE>
<TR valign="top" class="">
<TD><DIV class="toc_category"><A href="#Python_Language_Rules">Python语言规范</A></DIV></TD>
<TD><DIV class="toc_stylepoint">
<SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Lint">Lint</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Imports">导入</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Packages">包</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Exceptions">异常</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Global_variables">全局变量</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Nested/Local/Inner_Classes_and_Functions">嵌套/局部/内部 类和方法</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#List_Comprehensions">列表推导</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Default_Iterators_and_Operators">默认迭代器和运算符</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Generators">生成器</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Lambda_Functions">Lambda函数</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Conditional_Expressions">条件表达式</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Default_Argument_Values">默认参数值</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Properties">属性</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#True/False_evaluations">True/False 求值</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Deprecated_Language_Features">弃用的语言特性</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Lexical_Scoping">词法作用域(Lexical Scoping)</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Function_and_Method_Decorators">方法和函数装饰器</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Threading">线程</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Power_Features">激进的特性</A></SPAN> </DIV></TD>
</TR>
<TR valign="top" class="">
<TD><DIV class="toc_category"><A href="#Python_Style_Rules">Python风格规范</A></DIV></TD>
<TD><DIV class="toc_stylepoint">
<SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Semicolons">分号</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Line_length">行长度</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Parentheses">圆括号</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Indentation">缩进排版</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Blank_Lines">空白行</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Whitespace">空格</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Shebang_Line">组织行(Shebang Line)</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Comments">注释</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Classes">类</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Strings">字符串</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Files_and_Sockets">文件和Sockets</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#TODO_Comments">TODO注释</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Imports_formatting">导入格式</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Statements">语句</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Access_Control">访问控制</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Naming">命名</A></SPAN> <SPAN style="padding-right: 1em; white-space:nowrap;" class=""><A href="#Main">主函数(Main)</A></SPAN> </DIV></TD>
</TR>
</TABLE>
</DIV>
  <DIV class="">
<H2 name="Important_Note" id="Important_Note">重要提示！</H2>
    <DIV class="">
<H3><A name="Displaying_Hidden_Details_in_this_Guide" id="Displaying_Hidden_Details_in_this_Guide">在本文中显示隐藏的详情</A></H3>
<SPAN class="link_button" id="link-Displaying_Hidden_Details_in_this_Guide__button" name="link-Displaying_Hidden_Details_in_this_Guide__button"><A href="?showone=Displaying_Hidden_Details_in_this_Guide#Displaying_Hidden_Details_in_this_Guide">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Displaying_Hidden_Details_in_this_Guide')" name="Displaying_Hidden_Details_in_this_Guide__button" id="Displaying_Hidden_Details_in_this_Guide__button">▶</SPAN>
      <DIV style="display:inline;" class="">
       本指南中包含很多隐藏起来的详情内容，它们通过三角形图标标记，如同你现在看到这行的左侧的图标。点击一下，您应该可以看到下面出现了一些文字。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Displaying_Hidden_Details_in_this_Guide__body" id="Displaying_Hidden_Details_in_this_Guide__body" style="display: none">
       <p>哇，现在你知道了你可以展开一个论点来查看它的细节。此外，在文章顶部还有一个“展开/折叠全部”的按钮。
       </p>
      </DIV></DIV>
    </DIV>
  </DIV>
  <DIV class="">
<H2 name="Background" id="Background">背景</H2>
    <p>
    	在Google，Python是一门被主要使用的脚本语言。这份指南是一个在Python编程中 <em>“应该做”</em> 和 <em>“不应该做”</em> 的一个列表。
    </p>
    
    <p>
    	为了帮助你正确的格式化代码，我们创建了一个<a href="google_python_style.vim">Vim的配置文件</a>。在Emacs中，默认的设置应该就可以了。
    </p>
    
    
  </DIV>
  
  <DIV class="">
<H2 name="Python_Language_Rules" id="Python_Language_Rules">Python语言规范</H2>
     <DIV class="">
<H3><A name="Lint" id="Lint">Lint</A></H3>
<SPAN class="link_button" id="link-Lint__button" name="link-Lint__button"><A href="?showone=Lint#Lint">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Lint')" name="Lint__button" id="Lint__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        在你的代码上运行 <code>pylint</code>
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Lint__body" id="Lint__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
        pylint是一个可以在Python源码中查找Bugs和风格问题的工具。它查找那些典型的被编译器捕获的问题。
        因为Python的动态特性，一些警告可能会被错误的报出；然而这种误报会非常少。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
        能捕获那些容易被忽视的错误，如拼写错误，使用未赋值的变量等。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
        <code>pylint</code>不是完美的，利用它，我们有时需要：a）围绕它写一些代码 b)压制它的一些警告或者 c）改善它。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
		确保对你的代码进行<code>pylint</code>。抑制警告，如果它们出现的不合理，以便其他问题不被隐藏。
        </P>
        
        <p>
          抑制警告，你可以设置一个行级注释：:
        </p>
        
        <DIV class=""><PRE>
<span class="external"></span>dict = 'something awful'  # Bad Idea... pylint: disable=redefined-builtin</PRE></DIV>
        <p>
          pylint的警告都是通过一个字母数字代码(<code>C0112</code>) 和一个象征性的名字(<code>empty-docstring</code>)来识别的。
          在写新代码或者更新已经存在的代码时，更推荐使用符号名来标识。
        </p>
        <p>
          如果符号名不能够见名知意，就添加一个解释。
        </p>
        <p>
          这种方式的抑制有一个好处就是我们可以很容易地查找并回顾它们。
        </p>
        <p>
          你可以通过 <code>pylint --list-msgs</code>来获取一个pylint的警告列表。查看一个消息的更多详细信息，可使用<code>pylint --help-msg=C6409</code>
        </p>
        <p>
		  推荐使用<code>pylint: disable</code> 来代替弃用的旧形式<coyizhide>pylint: disable-msg</code>
        </p>
        <p>
          要抑制“未使用的参数”警告，可以通过使用`_'来标识未使用的参数或者在参数名的前缀上加`unused_'。在改变参数名是不可行的情况下，你可以在函数开始之前提及它们，例如：
        </p>
        <DIV class=""><PRE>
<span class="external"></span>def foo(a, unused_b, unused_c, d=None, e=None):
  <span class="external">  </span>_ = d, e
  <span class="external">  </span>return a
<span class="external"></span>
</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Imports" id="Imports">导入</A></H3>
<SPAN class="link_button" id="link-Imports__button" name="link-Imports__button"><A href="?showone=Imports#Imports">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Imports')" name="Imports__button" id="Imports__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        只对包和模块使用 <code>import</code>s
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Imports__body" id="Imports__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
          模块间共享代码的重用机制。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
		  命名空间的管理约定非常简单。每一个标识的来源都是用一种一致的方式来表明的；<code>x.Obj</code>意味着对象<code>Obj</code>被定义在模块<code>x</code>下。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN> 
		  模块名可能还会冲突。一些模块名太长，不方面使用。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
          使用<code>import x</code>来导入包和模块。
          <br>
          使用<code>from x import y</code> 在 <code>x</code> 是包前缀并且 <code>y</code>是没有前缀的模块名的地方
          <br>
          使用<code>from x import y as z</code> 如果被导入的两个模块都叫 <code>y</code> 或者 <code>y</code>是一个不方便使用的长名字。
        </P>
        例如模块 <code>sound.effects.echo</code> 可以以如下方式来导入:
    <DIV class=""><PRE>
<span class="external"></span>from sound.effects import echo
<span class="external"></span>...
<span class="external"></span>echo.EchoFilter(input, output, delay=0.7, atten=4)
<span class="external"></span>
</PRE></DIV>
    <p>
      导入时不要使用相对的命名，即使这个模块在同一个包中，请使用完整包名，这样可以防止无意间两次导入同一个包。
    </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Packages" id="Packages">包</A></H3>
<SPAN class="link_button" id="link-Packages__button" name="link-Packages__button"><A href="?showone=Packages#Packages">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Packages')" name="Packages__button" id="Packages__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        导入每一个模块时都使用模块的全路径.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Packages__body" id="Packages__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      避免模块名冲突。可以让查找模块更加简单。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      部署代码更难，因为你必须层次地复制包。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
          所有的新代码都应该通过它的完整包名来导入。
        </P>
      <p>
        导入应该如下所示:
      </p>
    
    <DIV class=""><PRE># Reference in code with complete name.
import sound.effects.echo

# Reference in code with just module name (首选这种方式).
from sound.effects import echo
</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Exceptions" id="Exceptions">异常</A></H3>
<SPAN class="link_button" id="link-Exceptions__button" name="link-Exceptions__button"><A href="?showone=Exceptions#Exceptions">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Exceptions')" name="Exceptions__button" id="Exceptions__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        可以使用异常，但必须小心地使用.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Exceptions__body" id="Exceptions__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      异常是一种跳出代码块正常的流程来处理错误或者其他的异常条件的方法
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      异常-捕获代码不会使正常的流程代码变得杂乱。它允许控制流程当某一条件发生时跳过多个框架，例如，从多层嵌套的函数中一步返回，而不是继续执行有异常的代码。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      可能引起控制流程混乱。当调用一个库时，容易漏掉异常情况。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
        
      异常必须遵循下列的某些条件：
        
        <ul>
          <li>如此挂起一个异常: <code>raise MyException('Error
            message')</code> 或者 <code>raise MyException</code>.  不要使用两个参数的方式 (<code>raise MyException, 'Error message'</code>) 或者弃用的基于字符串的异常 
            (<code>raise 'Error message'</code>).</li>
          <li>模块或包都应该定义它们自己特定域内的异常基类，这个异常基类应该继承Python内建的异常类。一个模块的异常基类应该被命名为<code>Error</code>.
            <DIV class=""><PRE>
<span class="external"></span>class Error(Exception):
  <span class="external">  </span>pass</PRE></DIV>
</li>
          <li>永远不要使用<code>except:</code>语句捕获所有异常，或者捕获<code>Exception</code> 或 <code>StandardError</code>，
            除非你是重挂起一个异常或者是你在线程的最外层(还是要打印一条异常消息)。Python在这点上非常宽容，<code>except:</code>真的会捕获到所有的异常，包括拼错的名字，sys.exit()调用, Ctrl+C 中断，
            单元测试失败和一些简单到你不想去捕获的所有其他种类的异常。</li>
          <li>
			最小化代码块中<code>try</code>/<code>except</code>的体积。一个<code>try</code>体积越大，你就越会触发一个期望之外的异常，
			这种情况下，<code>try</code>/<code>except</code>块会隐藏一个真正的错误。
          </li>
          <li>
				使用<code>finally</code>子句来执行那些在<code>try</code>块中有没有异常都应该被执行的代码。这通常是在善后时很有用，如，关闭一个文件。
		  </li>
          <li>当捕获到一个异常时，使用 <code>as</code> 而不是一个逗号，例如：
            <DIV class=""><PRE>
<span class="external"></span>try:
  <span class="external">  </span>raise Error
<span class="external"></span>except Error as error:
  <span class="external">  </span>pass</PRE></DIV>
</li>
        </ul>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Global_variables" id="Global_variables">全局变量</A></H3>
<SPAN class="link_button" id="link-Global_variables__button" name="link-Global_variables__button"><A href="?showone=Global_variables#Global_variables">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Global_variables')" name="Global_variables__button" id="Global_variables__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        避免使用全局变量.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Global_variables__body" id="Global_variables__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      那些被声明成模块级别的变量。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      偶尔是有用的。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
	  在导入时可能会潜在地改变一个模块的行为，因为当模块被导入时，模块级别的变量会被赋值。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
	  避免全局变量有利于类变量，一些例外如下：
      <ul>
        <li>脚本的默认选择项.</li>
        <li>模块级别的常量。如：<code>PI = 3.14159</code>。常量命名时应该全部大写并以下划线连接，请参考下方的<a HREF="#Naming">命名</a>.</li>
        <li>有时使用全局变量缓存一个必要的值或者通过函数返回的值是很有用的。</li>
        <li>如果需要，全局变量应该被设置成在模块内部可用，可以通过公共模块级别的函数进行访问；请参考下方的<a HREF="#Naming">命名</a></li>
      </ul>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Nested/Local/Inner_Classes_and_Functions" id="Nested/Local/Inner_Classes_and_Functions">嵌套/局部/内部 类和方法</A></H3>
<SPAN class="link_button" id="link-Nested/Local/Inner_Classes_and_Functions__button" name="link-Nested/Local/Inner_Classes_and_Functions__button"><A href="?showone=Nested/Local/Inner_Classes_and_Functions#Nested/Local/Inner_Classes_and_Functions">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Nested/Local/Inner_Classes_and_Functions')" name="Nested/Local/Inner_Classes_and_Functions__button" id="Nested/Local/Inner_Classes_and_Functions__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        嵌套/局部/内部 类和函数都可以用.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Nested/Local/Inner_Classes_and_Functions__body" id="Nested/Local/Inner_Classes_and_Functions__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
	  一个类可以被定义在一个方法，函数或者类的内部。一个函数可以被定义在一个方法或者另一个函数的内部。封闭区间中定义的变量对嵌套函数是只读的。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
	  允许定义仅在一个非常局限的范围内使用的实用类和函数。非常 <a HREF="http://en.wikipedia.org/wiki/Abstract_data_type">ADT</a>-y.
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      嵌套或局部类的实例不能被序列化。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      它们都是可以用的。
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="List_Comprehensions" id="List_Comprehensions">列表推导</A></H3>
<SPAN class="link_button" id="link-List_Comprehensions__button" name="link-List_Comprehensions__button"><A href="?showone=List_Comprehensions#List_Comprehensions">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('List_Comprehensions')" name="List_Comprehensions__button" id="List_Comprehensions__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        可以在简单的情况下使用.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="List_Comprehensions__body" id="List_Comprehensions__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      列表推导和生成器表达式提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助<code>map()</code>, <code>filter()</code>, 或<code>lambda</code>.
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      简单的列表推导可以比其他的列表生成技术更加简单明了。生成器表达式非常有效，因为它们避免了创建整个列表。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      复杂的列表推导和生成器表达式可能会难以阅读。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      在简单的情况下使用，每个部分应该独占一行：映射表达式，<code>for</code>语句，过滤表达式。
      多重<code>for</code>语句或者过滤表达式是被不允许使用的。如果事情变得复杂请使用循环来替代。
        </P>

<DIV class=""><PRE>Ye<span class="external"></span>s:
  <span class="external"></span>result = []
  <span class="external"></span>for x in range(10):
    <span class="external">  </span>for y in range(5):
      <span class="external">    </span>if x * y &gt; 10:
        <span class="external">      </span>result.append((x, y))

  <span class="external"></span>for x in xrange(5):
    <span class="external">  </span>for y in xrange(5):
      <span class="external">    </span>if x != y:
        <span class="external">      </span>for z in xrange(5):
          <span class="external">        </span>if y != z:
            <span class="external">          </span>yield (x, y, z)

  <span class="external"></span>return ((x, complicated_transform(x))
  <span class="external"></span>        for x in long_generator_function(parameter)
  <span class="external"></span>        if x is not None)

  <span class="external"></span>squares = [x * x for x in range(10)]

  <span class="external"></span>eat(jelly_bean for jelly_bean in jelly_beans
  <span class="external"></span>    if jelly_bean.color == 'black')</PRE></DIV>
<DIV class=""><PRE class="badcode">No<span class="external"></span>:
  <span class="external"></span>result = [(x, y) for x in range(10) for y in range(5) if x * y &gt; 10]

  <span class="external"></span>return ((x, y, z)
  <span class="external"></span>        for x in xrange(5)
  <span class="external"></span>        for y in xrange(5)
  <span class="external"></span>        if x != y
  <span class="external"></span>        for z in xrange(5)
  <span class="external"></span>        if y != z)</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Default_Iterators_and_Operators" id="Default_Iterators_and_Operators">默认的迭代器和运算符</A></H3>
<SPAN class="link_button" id="link-Default_Iterators_and_Operators__button" name="link-Default_Iterators_and_Operators__button"><A href="?showone=Default_Iterators_and_Operators#Default_Iterators_and_Operators">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Default_Iterators_and_Operators')" name="Default_Iterators_and_Operators__button" id="Default_Iterators_and_Operators__button">▶</SPAN>
      <DIV style="display:inline;" class="">
      	 如果类型支持，就使用默认的迭代器和运算符，如列表，字典，文件.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Default_Iterators_and_Operators__body" id="Default_Iterators_and_Operators__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      集合类型，像字典和列表，定义默认迭代器和成员测试操作符("in" 和 "not in").
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      默认的迭代器和操作符都是简单且高效的。它们直接表达操作，没有额外的方法调用。
      使用默认运算符的函数是通用的。它可以与任何它支持操作的类型在一起使用。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      你不能通过阅读方法名说出对象的类型(例如:has_key()意思是一个字典)。不过这也是一个优点。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN> 
      为那些支持它们的类型使用默认的迭代器和操作符，如列表，字段和文件。内建的类型也定义了迭代方法。
      优先考虑这些方法，而不是那些返回列表的方法。当然，在你遍历它时，你不能修改集合本身。

<DIV class=""><PRE>Yes:  <span class="external"></span>for key in adict: ...
      <span class="external"></span>if key not in adict: ...
      <span class="external"></span>if obj in alist: ...
      <span class="external"></span>for line in afile: ...
      <span class="external"></span>for k, v in dict.iteritems(): ...</PRE></DIV>
<DIV class=""><PRE class="badcode">No:   <span class="external"></span>for key in adict.keys(): ...
      <span class="external"></span>if not adict.has_key(key): ...
      <span class="external"></span>for line in afile.readlines(): ...</PRE></DIV>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Generators" id="Generators">生成器</A></H3>
<SPAN class="link_button" id="link-Generators__button" name="link-Generators__button"><A href="?showone=Generators#Generators">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Generators')" name="Generators__button" id="Generators__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        需要时使用生成器.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Generators__body" id="Generators__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      生成器函数返回一个在每一次执行它的产出语句时得到一个值的迭代器。在它产出一个值之后，生成器函数的运行状态是暂停的，直到下一个值被请求。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      代码简单，因为局部变量和控制流程的状态在每次调用时都被保存。
      由于可以一次就创建整个列的值，因此生成器比函数使用更少的内存。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
          无。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      推荐使用。为生成器函数的文档字符串中使用"Yields:"比"Returns:"更好。
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Lambda_Functions" id="Lambda_Functions">Lambda函数</A></H3>
<SPAN class="link_button" id="link-Lambda_Functions__button" name="link-Lambda_Functions__button"><A href="?showone=Lambda_Functions#Lambda_Functions">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Lambda_Functions')" name="Lambda_Functions__button" id="Lambda_Functions__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        在一行中是可以的.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Lambda_Functions__body" id="Lambda_Functions__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      与语句相反，Lambdas在一个表达式中定义了匿名函数。它们常被用作定义回调或者如<code>map()</code>和<code>filter()</code>之类的高阶函数操作符。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      方便。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN> 
      比局部函数难以阅读和调试。名字的确实意味着堆栈跟踪是理解更困难的。表现有一定的局限性，因为函数可能只包含一个表达式。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      在一行中使用它们是没有问题的。如果lambda函数中的代码长度超过60-80个字符，最好还是定义成常规(内嵌)函数。
       <p>
         对于诸如乘法之类的常规操作符，使用<code>operator</code>模块中的函数替代lambda函数。
         例如，<code>operator.mul</code>比<code>lambda x, y: x * y</code>更好。
       </p>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Conditional_Expressions" id="Conditional_Expressions">条件表达式</A></H3>
<SPAN class="link_button" id="link-Conditional_Expressions__button" name="link-Conditional_Expressions__button"><A href="?showone=Conditional_Expressions#Conditional_Expressions">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Conditional_Expressions')" name="Conditional_Expressions__button" id="Conditional_Expressions__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        在一行中是可以的.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Conditional_Expressions__body" id="Conditional_Expressions__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      条件表达式是比if语句更短的语法的一种机制。例如：<code>x = 1 if cond else 2</code>.
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      比if语句更加简短和方便。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      可能会比if语句难以阅读一些。如果表达式过长，定位会变得困难。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      在一行中使用是没问题的。在其他场景中使用完整的if语句会更好。
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Default_Argument_Values" id="Default_Argument_Values">默认参数值</A></H3>
<SPAN class="link_button" id="link-Default_Argument_Values__button" name="link-Default_Argument_Values__button"><A href="?showone=Default_Argument_Values#Default_Argument_Values">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Default_Argument_Values')" name="Default_Argument_Values__button" id="Default_Argument_Values__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        大多数情况下是可以的.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Default_Argument_Values__body" id="Default_Argument_Values__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      你可以在一个函数的参数列表的结尾指定参数的值，如<code>def foo(a, b=0):</code>。
      如果<code>foo</code>被仅有一个参数进行调用时，<code>b</code>就会被设置成0。
      如果它是通过两个参数进行调用时，<code>b</code>就会得到第二个参数的值。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      你经常会遇到一个有大量默认值的函数，但是你很少想去覆盖这些默认值。
      默认参数值提供了一种容易的方式去做到这点，可以不用为这些罕见的异常定义大量的函数。
      而且，Python不支持重载方法/函数，默认参数就是一种简单的方式来“假充”重载行为。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      默认参数在模块加载时赋值一次。这可能在参数是诸如列表或一个字段时带来一些问题。
      如果方法修改了对象(如添加一项到一个列表中)，默认值就被修改了。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      遵守下列警告时可以使用：
      <p>
        在函数或方法定义时，不要使用可变的对象作为默认值。
      </p>
<DIV class=""><PRE>Yes: <span class="external"></span>def foo(a, b=None):
       <span class="external">  </span>if b is None:
         <span class="external">    </span>b = []</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>def foo(a, b=[]):
       <span class="external">  </span>...
No:  <span class="external"></span>def foo(a, b=time.time()):  # The time the module was loaded???
       <span class="external">  </span>...
No:  <span class="external"></span>def foo(a, b=FLAGS.my_thing):  # sys.argv has not yet been parsed...
       <span class="external">  </span>...</PRE></DIV>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Properties" id="Properties">属性</A></H3>
<SPAN class="link_button" id="link-Properties__button" name="link-Properties__button"><A href="?showone=Properties#Properties">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Properties')" name="Properties__button" id="Properties__button">▶</SPAN>
      <DIV style="display:inline;" class="">
      使用属性来访问或者设置数据，在你通常会简单地，轻量级的访问或设置方法的数据的地方。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Properties__body" id="Properties__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN> 
        一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN> 
      通过消除简单属性访问时显式的get和set方法调用, 可读性提高了。允许延迟计算。
      用Pythonic方式维护类的接口。就性能而言，当直接访问变量是合理的， 添加访问方法就显得琐碎而无意义。
      使用属性可以绕过这个问题。将来也可以在不破坏接口的情况下将访问方法加上。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN> 
    属性是在getter和setter方法声明后指定的，
    这需要使用者在接下来的代码中注意: set和get是用于属性的(除了用 <code>@property</code> 装饰器创建的只读属性)。
    必须继承自<code>object</code>类。可能隐藏比如操作符重载之类的副作用。继承时可能会让人困惑。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN> 
      在你可以通常会使用简单，轻量的accessor或setter 方法的新代码中使用属性来访问或设置数据。只读属性可以通过带有<code>@property</code>的
      <a HREF="#Function_and_Method_Decorators">装饰器</a>来创建。

     <p><a id="properties-template-dp">
      如果属性自身没有被重写，那么继承的属性可以是非显式的。因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式)
     </a></p>

     <DIV class=""><PRE>Yes: <span class="external"></span>import math

     <span class="external"></span>class Square(object):
       <span class="external">  </span>"""A square with two properties: a writable area and a read-only perimeter.

       <span class="external">  </span>To use:
       <span class="external">  </span>&gt;&gt;&gt; sq = Square(3)
       <span class="external">  </span>&gt;&gt;&gt; sq.area
       <span class="external">  </span>9
       <span class="external">  </span>&gt;&gt;&gt; sq.perimeter
       <span class="external">  </span>12
       <span class="external">  </span>&gt;&gt;&gt; sq.area = 16
       <span class="external">  </span>&gt;&gt;&gt; sq.side
       <span class="external">  </span>4
       <span class="external">  </span>&gt;&gt;&gt; sq.perimeter
       <span class="external">  </span>16
       <span class="external">  </span>"""

       <span class="external">  </span>def __init__(self, side):
         <span class="external">    </span>self.side = side

       <span class="external">  </span>def __get_area(self):
         <span class="external">    </span>"""Calculates the 'area' property."""
         <span class="external">    </span>return self.side ** 2

       <span class="external">  </span>def ___get_area(self):
         <span class="external">    </span>"""Indirect accessor for 'area' property."""
         <span class="external">    </span>return self.__get_area()

       <span class="external">  </span>def __set_area(self, area):
         <span class="external">    </span>"""Sets the 'area' property."""
         <span class="external">    </span>self.side = math.sqrt(area)

       <span class="external">  </span>def ___set_area(self, area):
         <span class="external">    </span>"""Indirect setter for 'area' property."""
         <span class="external">    </span>self.__set_area(area)

       <span class="external">  </span>area = property(___get_area, ___set_area,
       <span class="external">  </span>                doc="""Gets or sets the area of the square.""")

       <span class="external">  </span>@property
       <span class="external">  </span>def perimeter(self):
         <span class="external">    </span>return self.side * 4
<span class="external"></span>
</PRE></DIV>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="True/False_evaluations" id="True/False_evaluations">True/False求值</A></H3>
<SPAN class="link_button" id="link-True/False_evaluations__button" name="link-True/False_evaluations__button"><A href="?showone=True/False_evaluations#True/False_evaluations">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('True/False_evaluations')" name="True/False_evaluations__button" id="True/False_evaluations__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        尽可能的使用隐式false
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="True/False_evaluations__body" id="True/False_evaluations__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN> 
      Python在布尔上下文中会将某些值求值为<code>false</code>。 
      按简单的直觉来讲, 就是所有的"空"值都被认为是<code>false</code>. 因此<code>0, None, [], {},''</code> 都被认为是<code>false</code>。
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
       使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      对C/C++开发人员来说, 可能看起来有点怪。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      尽可能使用隐式的false, 例如: 使用 <code>if foo:</code> 而不是 <code>if foo != []:</code> 。 不过还是有一些注意事项需要你铭记在心：
    <ul>
      <li>
        永远不要用<code>==</code>或者<code>!=</code> 来比较单件, 比如<code>None</code>. 使用<code>is</code>或者<code>is not</code>。
      </li>

      <li>
        注意: 当你写下 <code>if x:</code> 时, 你其实表示的是 <code>if x is not None:</code> 。 
        例如: 当你要测试一个默认值是<code>None</code>的变量或参数是否被设为其它值。这个值在布尔语义下可能是false! 
      </li>

      <li>
        永远不要用==将一个布尔量与<code>False</code>相比较。 使用 <code>if not x:</code>  代替。 
        如果你需要区分<code>False</code>和<code>None</code>, 你应该用像 <code>if not x and x is not None:</code> 这样的语句。
      </li>

      <li>
        对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此 <code>if not seq:</code> 或者 <code>if seq:</code> 比 <code>if len(seq):</code> 或 <code>if not len(seq):</code> 要更好。
      </li>

      <li>
         处理整数时, 使用隐式false可能会得不偿失(即不小心将<code>None</code>当做0来处理). 你可以将一个已知是整型(且不是<code>len()</code>的返回结果)的值与0比较。
<DIV class=""><PRE>Yes: <span class="external"></span>if not users:
       <span class="external">  </span>print 'no users'

     <span class="external"></span>if foo == 0:
       <span class="external">  </span>self.handle_zero()

     <span class="external"></span>if i % 10 == 0:
       <span class="external">  </span>self.handle_multiple_of_ten()</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>if len(users) == 0:
       <span class="external">  </span>print 'no users'

     <span class="external"></span>if foo is not None and not foo:
       <span class="external">  </span>self.handle_zero()

     <span class="external"></span>if not i % 10:
       <span class="external">  </span>self.handle_multiple_of_ten()</PRE></DIV>
</li>

      <li>
        注意：<code>'0'</code> (如, <code>0</code> 作为一个字符串)将被推导成true。</li>
    </ul>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Deprecated_Language_Features" id="Deprecated_Language_Features">弃用的语言特性</A></H3>
<SPAN class="link_button" id="link-Deprecated_Language_Features__button" name="link-Deprecated_Language_Features__button"><A href="?showone=Deprecated_Language_Features#Deprecated_Language_Features">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Deprecated_Language_Features')" name="Deprecated_Language_Features__button" id="Deprecated_Language_Features__button">▶</SPAN>
      <DIV style="display:inline;" class="">
      	尽可能的使用string方法来替代<code>string</code>模块。使用函数调用语句来替代<code>apply</code>。
      	当函数参数是一个内联lambda表达式时，使用列表推导和<code>for</code> 循环来替代<code>filter</code>和<code>map</code> 。
      	使用<code>for</code>循环替代<code>reduce</code>。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Deprecated_Language_Features__body" id="Deprecated_Language_Features__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
          当前版本的Python提供了大家通常更喜欢的替代品。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
          我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式。
<DIV class=""><PRE>Yes: <span class="external"></span>words = foo.split(':')

     <span class="external"></span>[x[1] for x in my_list if x[2] == 5]

     <span class="external"></span>map(math.sqrt, data)    # Ok. No inlined lambda expression.

     <span class="external"></span>fn(*args, **kwargs)</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>words = string.split(foo, ':')

     <span class="external"></span>map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list))

     <span class="external"></span>apply(fn, args, kwargs)</PRE></DIV>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Lexical_Scoping" id="Lexical_Scoping">词法作用域(Lexical Scoping)</A></H3>
<SPAN class="link_button" id="link-Lexical_Scoping__button" name="link-Lexical_Scoping__button"><A href="?showone=Lexical_Scoping#Lexical_Scoping">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Lexical_Scoping')" name="Lexical_Scoping__button" id="Lexical_Scoping__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        可以使用.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Lexical_Scoping__body" id="Lexical_Scoping__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 
      变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 
      对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 
      甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量.

    <p>
      使用此功能的一个例子：
    </p>

    <DIV class=""><PRE>
<span class="external"></span>def get_adder(summand1):
  <span class="external">  </span>"""Returns a function that adds numbers to a given number."""
  <span class="external">  </span>def adder(summand2):
    <span class="external">    </span>return summand1 + summand2

  <span class="external">  </span>return adder
<span class="external"></span>
</PRE></DIV>
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      通常会产生清晰的，高雅的代码。尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      可能会产生让人迷惑的Bug,如基于<a HREF="http://www.python.org/dev/peps/pep-0227/">PEP-0227</a>的一个例子：:
<DIV class=""><PRE class="badcode">
<span class="external"></span>i = 4
<span class="external"></span>def foo(x):
  <span class="external">  </span>def bar():
    <span class="external">    </span>print i,
  <span class="external">  </span># ...
  <span class="external">  </span># A bunch of code here
  <span class="external">  </span># ...
  <span class="external">  </span>for i in x:  # Ah, i *is* local to Foo, so this is what Bar sees
    <span class="external">    </span>print i,
  <span class="external">  </span>bar()</PRE></DIV>
      <p>
        因此 <code>foo([1, 2, 3])</code> 将打印出 <code>1 2 3 3</code>, 而非<code>1 2 3 4</code>.
      </p>
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
      可以使用。
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Function_and_Method_Decorators" id="Function_and_Method_Decorators">方法和函数装饰器</A></H3>
<SPAN class="link_button" id="link-Function_and_Method_Decorators__button" name="link-Function_and_Method_Decorators__button"><A href="?showone=Function_and_Method_Decorators#Function_and_Method_Decorators">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Function_and_Method_Decorators')" name="Function_and_Method_Decorators__button" id="Function_and_Method_Decorators__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        如果好处显然，就明智且谨慎地使用装饰器。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Function_and_Method_Decorators__body" id="Function_and_Method_Decorators__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN>
      
      <a HREF="http://www.python.org/doc/2.4.3/whatsnew/node6.html">方法和函数装饰器</a>
      (也称为 " <code>@</code> 标记").
      最常见的装饰圈是 <code>@classmethod</code> 和 <code>@staticmethod</code>, 
      用于将普通的函数转变成类或静态函数。然而，装饰器语法也允许用户自定义的装饰器。特别是对一些函数<code>my_decorator</code>，下列两段代码是等价的：
      <DIV class=""><PRE>
<span class="external"></span>class C(object):
  <span class="external">  </span>@my_decorator
  <span class="external">  </span>def method(self):
    <span class="external">    </span># method body ...
<span class="external"></span>
</PRE></DIV>

      <DIV class=""><PRE>
<span class="external"></span>class C(object):
  <span class="external">  </span>def method(self):
    <span class="external">    </span># method body ...
  <span class="external">  </span>method = my_decorator(method)
<span class="external"></span>
</PRE></DIV>
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN>
      对一个方法优美地指定一些转化；这些转化可能会消除一些重复代码，加强不变性，等。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN> 
      装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为。此外, 装饰器在导入时执行，从装饰器代码的失败中恢复更加不可能。
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN> 
      如果好处显然, 就明智而谨慎的使用装饰器。装饰器应该遵守和函数一样的导入和命名规则。
      装饰器的python文档应该清晰的说明该函数是一个装饰器。 请为装饰器编写单元测试。

    <p>
      避免装饰器自身对外界的依赖(如：不要依赖于文件, socket, 数据库连接等), 
      因为装饰器运行时这些资源可能不可用(在导入时，也许是由 <code>pydoc</code> 或其它工具导入)。
      应该保证一个用有效参数调用的装饰器在所有情况下都是成功的。
    </p>
    <p>
      装饰器是“顶级代码”的一种特殊情况 - 参见 <a HREF="#Main">main</a>了解更多信息。
    </p>
        </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Threading" id="Threading">线程</A></H3>
<SPAN class="link_button" id="link-Threading__button" name="link-Threading__button"><A href="?showone=Threading#Threading">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Threading')" name="Threading__button" id="Threading__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        不要依赖内建类型的原子性。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Threading__body" id="Threading__body" style="display: none">
        <p>
          虽然Python的内建数据类型例如字典看上去拥有原子操作, 
          但是在某些情形下它们仍然不是原子的(例如: 如果code>__hash__</code>或<code>__eq__</code>被实现为Python方法)且它们的原子性是不可靠的。
          你也不能指望原子变量赋值(因为这个反过来依赖于字典)。
        </p>

        <p>
          优先使用Queue模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式。
          另外, 使用threading模块及其锁原语(locking primitives)。
          了解条件变量的合适使用方式, 这样你就可以使用 <code>threading.Condition</code> 来取代低级别的锁了。
        </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Power_Features" id="Power_Features">激进的特性</A></H3>
<SPAN class="link_button" id="link-Power_Features__button" name="link-Power_Features__button"><A href="?showone=Power_Features#Power_Features">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Power_Features')" name="Power_Features__button" id="Power_Features__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        避开这些特性。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Power_Features__body" id="Power_Features__body" style="display: none">
        <P class="">
<SPAN class="stylepoint_section">定义:  </SPAN> 
       Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 
       访问字节码, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 
       导入作弊(import hacks), 反射, 系统内修改(modification of system internals), 等等
        </P>
        <P class="">
<SPAN class="stylepoint_section">优点:  </SPAN> 
      这些都是强大的语言功能，它们可以让你的代码更简洁。
        </P>
        <P class="">
<SPAN class="stylepoint_section">缺点: </SPAN>
      使用这些很"酷"的特性十分诱人, 但不是绝对必要。
      使用奇技淫巧的代码将更加难以阅读和调试。开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解.
        </P>
        <P class="">
<SPAN class="stylepoint_section">结论:  </SPAN>
          避免这些特性出现在你的代码中。
        </P>
      </DIV></DIV>
    </DIV>
  </DIV>
  <DIV class="">
<H2 name="Python_Style_Rules" id="Python_Style_Rules">Python风格规范</H2>
    <DIV class="">
<H3><A name="Semicolons" id="Semicolons">分号</A></H3>
<SPAN class="link_button" id="link-Semicolons__button" name="link-Semicolons__button"><A href="?showone=Semicolons#Semicolons">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Semicolons')" name="Semicolons__button" id="Semicolons__button">▶</SPAN>
      <DIV style="display:inline;" class="">
      	不要在行尾加分号，也不要用分号把两条语句放在同一行。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Semicolons__body" id="Semicolons__body" style="display: none">
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Line_length" id="Line_length">行长度</A></H3>
<SPAN class="link_button" id="link-Line_length__button" name="link-Line_length__button"><A href="?showone=Line_length#Line_length">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Line_length')" name="Line_length__button" id="Line_length__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        行最大长度为 <em>80个字符</em>.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Line_length__body" id="Line_length__body" style="display: none">
    <p>
      例外:
      <ul>
        <li>长的导入语句</li>
        <li>注释中的URLs</li>
        
      </ul>
    </p>

    <p>
      不用使用反斜杠延续行
    </p>

    <p>
      利用Python的<a HREF="http://docs.python.org/reference/lexical_analysis.html#implicit-line-joining">圆括号，中括号和花括号中的隐式连接</a>。
      如果必要，你可以添加在一个表达式两边添加额外的圆括号。
    </p>

    
    <DIV class=""><PRE>Yes: foo_bar(self, width, height, color='black', design=None, x='foo',
             emphasis=None, highlight=0)

     if (width == 0 and height == 0 and
         color == 'red' and emphasis == 'strong'):</PRE></DIV>


    <p>
      当字符串过长不适应放在一个单独的行中，使用圆括号隐式地连接行。
    </p>

    <DIV class=""><PRE>
<span class="external"></span>x = ('This will build a very long long '
<span class="external"></span>     'long long long long long long string')</PRE></DIV>

    <p>
      在注释内部，如果有必要可以将过长的URLs放在它们自己的行中。
    </p>

    <DIV class=""><PRE>Yes:  <span class="external"></span># See details at
      <span class="external"></span># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</PRE></DIV>

    <DIV class=""><PRE class="badcode">No:  <span class="external"></span># See details at
     <span class="external"></span># http://www.example.com/us/developer/documentation/api/content/\
     <span class="external"></span># v2.0/csv_file_name_extension_full_specification.html</PRE></DIV>

    <p>
      注意上面例子中的元素缩进; 你可以在<a HREF="#Indentation">缩进 </a>部分找到解释。
    </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Parentheses" id="Parentheses">圆括号</A></H3>
<SPAN class="link_button" id="link-Parentheses__button" name="link-Parentheses__button"><A href="?showone=Parentheses#Parentheses">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Parentheses')" name="Parentheses__button" id="Parentheses__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        少量的使用圆括号.
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Parentheses__body" id="Parentheses__body" style="display: none">
    <p>
      不要在返回语句或者条件语句中使用它们，除非为隐式的行连接使用圆括号(参加上一条)。
      在元组(tuples)两边使用圆括号总是对的。
    </p>

<DIV class=""><PRE>Yes: <span class="external"></span>if foo:
       <span class="external">  </span>bar()
     <span class="external"></span>while x:
       <span class="external">  </span>x = bar()
     <span class="external"></span>if x and y:
       <span class="external">  </span>bar()
     <span class="external"></span>if not x:
       <span class="external">  </span>bar()
     <span class="external"></span>return foo
     <span class="external"></span>for (x, y) in dict.items(): ...</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>if (x):
       <span class="external">  </span>bar()
     <span class="external"></span>if not(x):
       <span class="external">  </span>bar()
     <span class="external"></span>return (foo)</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Indentation" id="Indentation">缩进排版</A></H3>
<SPAN class="link_button" id="link-Indentation__button" name="link-Indentation__button"><A href="?showone=Indentation#Indentation">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Indentation')" name="Indentation__button" id="Indentation__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        使用 <em>4个空格</em> 来缩进你的代码块。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Indentation__body" id="Indentation__body" style="display: none">
    <p>
      永远别使用tab或混合tab和空格。
      在隐式行连接情景下，你应该垂直地包裹元素，如同之前<a HREF="#Line_length">行长度</a>章节中的例子；
      或者使用一个4空格悬挂式缩进，这种情况下在第一行中不应该有参数。
    </p>


<DIV class=""><PRE>Yes:   # Aligned with opening delimiter
       foo = long_function_name(var_one, var_two,
                                var_three, var_four)

       # Aligned with opening delimiter in a dictionary
       foo = {
           long_dictionary_key: value1 +
                                value2,
           ...
       }

       # 4-space hanging indent; nothing on first line
       foo = long_function_name(
           var_one, var_two, var_three,
           var_four)

       # 4-space hanging indent in a dictionary
       foo = {
           long_dictionary_key:
               long_dictionary_value,
           ...
       }</PRE></DIV>
<DIV class=""><PRE class="badcode">No:    <span class="external"></span># Stuff on first line forbidden
       <span class="external"></span>foo = long_function_name(var_one, var_two,
       <span class="external"></span>    var_three, var_four)

       <span class="external"></span># 2-space hanging indent forbidden
       <span class="external"></span>foo = long_function_name(
       <span class="external"></span>  var_one, var_two, var_three,
       <span class="external"></span>  var_four)

       <span class="external"></span># No hanging indent in a dictionary
       <span class="external"></span>foo = {
       <span class="external"></span>    long_dictionary_key:
           <span class="external">    </span>long_dictionary_value,
           <span class="external">    </span>...
       <span class="external"></span>}</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Blank_Lines" id="Blank_Lines">空白行</A></H3>
<SPAN class="link_button" id="link-Blank_Lines__button" name="link-Blank_Lines__button"><A href="?showone=Blank_Lines#Blank_Lines">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Blank_Lines')" name="Blank_Lines__button" id="Blank_Lines__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        在顶级定义之间使用两行空白行，在方法定义之间使用一行空白行。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Blank_Lines__body" id="Blank_Lines__body" style="display: none">
    <p>
      顶级定义之间空两行, 比如函数或者类定义。
      方法定义, 类定义与第一个方法之间, 都应该空一行。
      函数或方法中, 某些地方要是你觉得合适, 就空一行。
    </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Whitespace" id="Whitespace">空格</A></H3>
<SPAN class="link_button" id="link-Whitespace__button" name="link-Whitespace__button"><A href="?showone=Whitespace#Whitespace">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Whitespace')" name="Whitespace__button" id="Whitespace__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        安装标准的排版规则来使用标点两边的空格。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Whitespace__body" id="Whitespace__body" style="display: none">
    <p>
      圆括号，中括号，花括号的里面不要有空格。
    </p>
<DIV class=""><PRE>Yes: <span class="external"></span>spam(ham[1], {eggs: 2}, [])</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>spam( ham[ 1 ], { eggs: 2 }, [ ] )</PRE></DIV>
    <p>
      逗号，分号，冒号之前不要有空格。在逗号，分号，冒号之后使用一个空格，除了在行尾。
    </p>
<DIV class=""><PRE>Yes: <span class="external"></span>if x == 4:
       <span class="external">  </span>print x, y
     <span class="external"></span>x, y = y, x</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>if x == 4 :
       <span class="external">  </span>print x , y
     <span class="external"></span>x , y = y , x</PRE></DIV>
    <p>
      参数列表, 索引或切片的左括号前不要加空格。
    </p>
    <DIV class=""><PRE>Yes: <span class="external"></span>spam(1)</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>spam (1)</PRE></DIV>
<DIV class=""><PRE>Yes: <span class="external"></span>dict['key'] = list[index]</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>dict ['key'] = list [index]</PRE></DIV>

    <p>
      在二元操作符两边都加上一个空格, 比如赋值(<code>=</code>), 
      比较(<code>==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not</code>), 
      布尔(<code>and, or, not</code>)。 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致。
    </p>
<DIV class=""><PRE>Yes: <span class="external"></span>x == 1</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>x&lt;1</PRE></DIV>
    <p>
      当'='用于指示关键字参数或默认参数值时, 不要在其两侧使用空格。
    </p>
<DIV class=""><PRE>Yes: <span class="external"></span>def complex(real, imag=0.0): return magic(r=real, i=imag)</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>def complex(real, imag = 0.0): return magic(r = real, i = imag)</PRE></DIV>

    <p>
      不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于<code>:</code>, <code>#</code>,<code>=</code>等):
    </p>
<DIV class=""><PRE>Yes:
  foo = 1000  # comment
  long_name = 2  # comment that should not be aligned

  dictionary = {
      'foo': 1,
      'long_name': 2,
  }</PRE></DIV>
<DIV class=""><PRE class="badcode">No:
  foo       = 1000  # comment
  long_name = 2     # comment that should not be aligned

  dictionary = {
      'foo'      : 1,
      'long_name': 2,
  }</PRE></DIV>

    
      </DIV></DIV>
    </DIV>

    <a name="Python_Interpreter"></a>
    <DIV class="">
<H3><A name="Shebang_Line" id="Shebang_Line">组织行(Shebang Line)</A></H3>
<SPAN class="link_button" id="link-Shebang_Line__button" name="link-Shebang_Line__button"><A href="?showone=Shebang_Line#Shebang_Line">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Shebang_Line')" name="Shebang_Line__button" id="Shebang_Line__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        大多数 <code>.py</code> 文件不需要以一个 <code>#!</code> 行开始。根据<a href="http://www.python.org/dev/peps/pep-0394/">PEP-394</a>，程序的main文件应该以
        <code>#!/usr/bin/python2</code>或<code>#!/usr/bin/python3</code>开始。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Shebang_Line__body" id="Shebang_Line__body" style="display: none">
        
        <p>
          这一行被用作查找Python编译器的核心，但是当导入模块时，会被Python忽略。
          它只需在一个将会被直接执行的文件中引入。
        </p>
      </DIV></DIV>
    </DIV>

    <DIV class="">
<H3><A name="Comments" id="Comments">注释</A></H3>
<SPAN class="link_button" id="link-Comments__button" name="link-Comments__button"><A href="?showone=Comments#Comments">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Comments')" name="Comments__button" id="Comments__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        确保在模块，函数，方法和行内都使用格式正确的注释。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Comments__body" id="Comments__body" style="display: none">

    <P class="">
<SPAN class="stylepoint_subsection">文档字符串</SPAN>

    <p>
      Python有一种独一无二的的注释方式: 使用文档字符串。
      文档字符串是包, 模块, 类或函数里的第一条语句。
      这些字符串可以通过对象的<code>__doc__</code>成员被自动提取, 并且被<code>pydoc</code>所用。
      (你可以在你的模块上运行<code>pydoc</code>试一下, 看看它是怎样的)。
      我们总是对文档字符串使用三重双引号<code>"""</code>(<a href="http://www.python.org/dev/peps/pep-0257/">PEP 257</a>)。
      一个文档字符串应该被组织成：一个以句号，问号或叹号结束的摘要行(或者该文档字符串单纯只有一行)。
      接着是一个空行，再接着是文档字符串剩余的部分，它应该和文档字符串的第一行的第一个引号对齐。
      以下有更多关于文档字符串的规范指南。
    </p>

    </P>
    <P class="">
<SPAN class="stylepoint_subsection">模块</SPAN>

    
    
    <p>
      每个文件应该包含一个许可样板。根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板
    </p>
    </P>
    <P class="">
<SPAN class="stylepoint_subsection">方法和函数</SPAN>

    <p>
      本节所指的函数包括函数, 方法, 和生成器。
    </p>

    <p>
      一个函数必须要有文档字符串, 除非它满足以下所有条件：
      <ul>
        <li>外部不可见</li>
        <li>非常短小</li>
        <li>简单明了</li>
      </ul>
    </p>

    <p>
      文档字符串应该给出足够的信息，可以使不阅读方法代码的情况下就可以调用一个函数。
      文档字符串应该描述函数的调用语法和它的语义，而不是它的实现过程。
      对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有合适。

    </p>

    <p>
      关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述。
      每节应该以一个标题行开始，标题行以冒号结尾。除标题行外, 节的其他内容应被缩进2个空格。
    </p>

    <dl>
      <dt>参数:</dt>
      <dd>
        列出每个参数的名字。并在名字后使用一个冒号和一个空格, 分隔对该参数的描述。
        如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。
        <p>
          描述应该包括所需参数的类型和含义。
        </p>

        <p>

        如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar。
        </p>
      </dd>

      <dt>返回: (或者 生成器的Yields:)</dt>
      <dd>
        描述返回值的类型和语义。 如果函数返回None, 这一部分就不是必须填写的。
      </dd>

      <dt>挂起:</dt>
      <dd>
        列出与接口有关的所有异常。
      </dd>
    </dl>

    <DIV class=""><PRE>
<span class="external"></span>def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
  <span class="external">  </span>"""Fetches rows from a Bigtable.

  <span class="external">  </span>Retrieves rows pertaining to the given keys from the Table instance
  <span class="external">  </span>represented by big_table.  Silly things may happen if
  <span class="external">  </span>other_silly_variable is not None.

  <span class="external">  </span>Args:
    <span class="external">    </span>big_table: An open Bigtable Table instance.
    <span class="external">    </span>keys: A sequence of strings representing the key of each table row
    <span class="external">    </span>    to fetch.
    <span class="external">    </span>other_silly_variable: Another optional variable, that has a much
    <span class="external">    </span>    longer name than the other args, and which does nothing.

  <span class="external">  </span>Returns:
    <span class="external">    </span>A dict mapping keys to the corresponding table row data
    <span class="external">    </span>fetched. Each row is represented as a tuple of strings. For
    <span class="external">    </span>example:

    <span class="external">    </span>{'Serak': ('Rigel VII', 'Preparer'),
    <span class="external">    </span> 'Zim': ('Irk', 'Invader'),
    <span class="external">    </span> 'Lrrr': ('Omicron Persei 8', 'Emperor')}

    <span class="external">    </span>If a key from the keys argument is missing from the dictionary,
    <span class="external">    </span>then that row was not found in the table.

  <span class="external">  </span>Raises:
    <span class="external">    </span>IOError: An error occurred accessing the bigtable.Table object.
  <span class="external">  </span>"""
  <span class="external">  </span>pass
<span class="external"></span>
</PRE></DIV>
    </P>
    <P class="">
<SPAN class="stylepoint_subsection">类</SPAN>

    <p>
      类应该在其定义下有一个用于描述该类的文档字符串。
      如果你的类有公共属性, 那么文档中应该有一个属性段落。
      并且应该遵守和函数参数相同的格式。
    </p>

    <DIV class=""><PRE>
<span class="external"></span>class SampleClass(object):
  <span class="external">  </span>"""Summary of class here.

  <span class="external">  </span>Longer class information....
  <span class="external">  </span>Longer class information....

  <span class="external">  </span>Attributes:
    <span class="external">    </span>likes_spam: A boolean indicating if we like SPAM or not.
    <span class="external">    </span>eggs: An integer count of the eggs we have laid.
  <span class="external">  </span>"""

  <span class="external">  </span>def __init__(self, likes_spam=False):
    <span class="external">    </span>"""Inits SampleClass with blah."""
    <span class="external">    </span>self.likes_spam = likes_spam
    <span class="external">    </span>self.eggs = 0

  <span class="external">  </span>def public_method(self):
    <span class="external">    </span>"""Performs operation blah."""
<span class="external"></span>
</PRE></DIV>

    </P>
    <P class="">
<SPAN class="stylepoint_subsection">块和行内注释</SPAN>

    <p>
      最需要写注释的是代码中那些难以理解的部分。
      如果你在下次<a HREF="http://en.wikipedia.org/wiki/Code_review">code review</a>的时候必须解释一下, 
      那么你应该现在就给它写注释。对于复杂的操作, 应该在其操作开始前写上若干行注释。
      对于不是一目了然的代码, 应在其行尾添加注释.

    </p>

    <DIV class=""><PRE>
<span class="external"></span># We use a weighted dictionary search to find out where i is in
<span class="external"></span># the array.  We extrapolate position based on the largest num
<span class="external"></span># in the array and the array size and then do binary search to
<span class="external"></span># get the exact number.

<span class="external"></span>if i &amp; (i-1) == 0:        # true iff i is a power of 2
<span class="external"></span>
</PRE></DIV>

    <p>
      为了提高可读性, 注释应该至少离开代码2个空格。
    </p>

    <p>
      另一方面, 绝不要描述代码。可以假设阅读代码的人比你更懂Python（他只是不知道你的代码要做什么）。
    </p>

    <DIV class=""><PRE class="badcode">
<span class="external"></span># BAD COMMENT: Now go through the b array and make sure whenever i occurs
<span class="external"></span># the next element is i+1
<span class="external"></span>
</PRE></DIV>

    </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Classes" id="Classes">类</A></H3>
<SPAN class="link_button" id="link-Classes__button" name="link-Classes__button"><A href="?showone=Classes#Classes">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Classes')" name="Classes__button" id="Classes__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        如果一个类不继承自其他类，那么就显示地继承<code>object</code>，这也适用于嵌套类。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Classes__body" id="Classes__body" style="display: none">
    <DIV class=""><PRE>Yes: <span class="external"></span>class SampleClass(object):
       <span class="external">  </span>pass


     <span class="external"></span>class OuterClass(object):

       <span class="external">  </span>class InnerClass(object):
         <span class="external">    </span>pass


     <span class="external"></span>class ChildClass(ParentClass):
       <span class="external">  </span>"""Explicitly inherits from another class already."""
<span class="external"></span>
</PRE></DIV>
    <DIV class=""><PRE class="badcode">No: <span class="external"></span>class SampleClass:
      <span class="external">  </span>pass


    <span class="external"></span>class OuterClass:

      <span class="external">  </span>class InnerClass:
        <span class="external">    </span>pass
<span class="external"></span>
</PRE></DIV>
    <p>

    继承自 <code>object</code> 是使属性(properties)正常工作所必需的, 
    并且这样可以保护你的代码, 使其不受Python 3000的一个特殊的潜在不兼容性影响。
    这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 
    包括 <code>__new__</code>, <code>__init__</code>, <code>__delattr__</code>,
    <code>__getattribute__</code>, <code>__setattr__</code>,
    <code>__hash__</code>, <code>__repr__</code>, 和 <code>__str__</code>。
    </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Strings" id="Strings">字符串</A></H3>
<SPAN class="link_button" id="link-Strings__button" name="link-Strings__button"><A href="?showone=Strings#Strings">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Strings')" name="Strings__button" id="Strings__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        使用<code>format</code>方法或者<code>%</code>操作符来格式化字符串，即便是参数都是字符串也这样。用你的最佳判断来觉得在<code>+</code> 和<code>%</code>之间进行取舍。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Strings__body" id="Strings__body" style="display: none">

<DIV class=""><PRE>Yes: <span class="external"></span>x = a + b
     <span class="external"></span>x = '%s, %s!' % (imperative, expletive)
     <span class="external"></span>x = '{}, {}!'.format(imperative, expletive)
     <span class="external"></span>x = 'name: %s; score: %d' % (name, n)
     <span class="external"></span>x = 'name: {}; score: {}'.format(name, n)</PRE></DIV>
<DIV class=""><PRE class="badcode">No: <span class="external"></span>x = '%s%s' % (a, b)  # use + in this case
    <span class="external"></span>x = '{}{}'.format(a, b)  # use + in this case
    <span class="external"></span>x = imperative + ', ' + expletive + '!'
    <span class="external"></span>x = 'name: ' + name + '; score: ' + str(n)</PRE></DIV>

    <p>

      避免在循环中用<code>+</code>和<code>+=</code>操作符来累加字符串。
      由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间。
      作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>''.join</code> 连接列表。(或者将每个子串写入一个 <code>io.BytesIO</code> 缓存中)

    </p>

<DIV class=""><PRE>Yes: <span class="external"></span>items = ['&lt;table&gt;']
     <span class="external"></span>for last_name, first_name in employee_list:
       <span class="external">  </span>items.append('&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;' % (last_name, first_name))
     <span class="external"></span>items.append('&lt;/table&gt;')
     <span class="external"></span>employee_table = ''.join(items)</PRE></DIV>
<DIV class=""><PRE class="badcode">No: <span class="external"></span>employee_table = '&lt;table&gt;'
    <span class="external"></span>for last_name, first_name in employee_list:
      <span class="external">  </span>employee_table += '&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;' % (last_name, first_name)
    <span class="external"></span>employee_table += '&lt;/table&gt;'</PRE></DIV>

    <p>
      在同一个文件中, 保持使用字符串引号的一致性。
      使用单引号<code>'</code>或者双引号<code>"</code>之一用以引用字符串, 并在同一文件中沿用。
      在字符串内可以使用另外一种引号, 以避免在字符串中使用反斜杠<code>\</code>。PyLint强制这样做。
    </p>

<DIV class=""><PRE>Ye<span class="external"></span>s:
  <span class="external"></span>Python('Why are you hiding your eyes?')
  <span class="external"></span>Gollum("I'm scared of lint errors.")
  <span class="external"></span>Narrator('"Good!" thought a happy Python reviewer.')</PRE></DIV>
<DIV class=""><PRE class="badcode">No<span class="external"></span>:
  <span class="external"></span>Python("Why are you hiding your eyes?")
  <span class="external"></span>Gollum('The lint. It burns. It burns us.')
  <span class="external"></span>Gollum("Always the great lint. Watching. Watching.")</PRE></DIV>

    <p>
      为多行字符串使用三重双引号<code>"""</code> 而非三重单引号<code>'''</code>。
      当且仅当项目中使用单引号<code>'</code>来引用字符串时，
      才可能会使用三重单引号<code>'''</code>为非文档字符串的多行字符串来标识引用。
      文档字符串必须使用三重双引号<code>"""</code>。
      不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致：
    </p>

<DIV class=""><PRE>Ye<span class="external"></span>s:
  <span class="external"></span>print ("This is much nicer.\n"
  <span class="external"></span>       "Do it this way.\n")</PRE></DIV>
<DIV class=""><PRE class="badcode">  No<span class="external"></span>:
    <span class="external"></span>print """This is pretty ugly.
Don'<span class="external"></span>t do this.
"""<span class="external"></span>
</PRE></DIV>

      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Files_and_Sockets" id="Files_and_Sockets">文件和Sockets</A></H3>
<SPAN class="link_button" id="link-Files_and_Sockets__button" name="link-Files_and_Sockets__button"><A href="?showone=Files_and_Sockets#Files_and_Sockets">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Files_and_Sockets')" name="Files_and_Sockets__button" id="Files_and_Sockets__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        当用完时，显示地关闭文件和sockets。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Files_and_Sockets__body" id="Files_and_Sockets__body" style="display: none">
        <p>
          处于打开状态就离开文件，sockets或者其它类似文件的对象，会带来很多不必要的缺陷，包括：
          <ul>
            <li>
              它们可能会消耗有限的系统资源, 如文件描述符。如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽。
            </li>
            <li>
              保持文件打开可能会阻止对于文件的其他操作，如移动、删除。
            </li>
            <li>
              文件和sockets在整个程序中共用可能会在逻辑关闭后被无意的读取或者写入。
              如果事实上已经关闭了，试图去读或写都会抛出异常，这样就可以让问题更快被知道。
            </li>
          </ul>
        </p>

        <p>
          而且, 虽然文件和sockets会在文件对象销毁时自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因：
          <ul>
            <li>
              没有任何方法可以确保运行时会真正的执行文件的析构。不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长。
            </li>
            <li>
              对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等)
            </li>
          </ul>
        </p>

        <p>
          推荐使用<a HREF="http://docs.python.org/reference/compound_stmts.html#the-with-statement"> "with" 语句</a>来管理文件:
        </p>

<DIV class=""><PRE>
<span class="external"></span>with open("hello.txt") as hello_file:
  <span class="external">  </span>for line in hello_file:
    <span class="external">    </span>print line</PRE></DIV>

        <p>
          对于不支持使用"with"语句的类似文件的对象,使用 contextlib.closing():
        </p>

<DIV class=""><PRE>
<span class="external"></span>import contextlib

<span class="external"></span>with contextlib.closing(urllib.urlopen("http://www.python.org/")) as front_page:
  <span class="external">  </span>for line in front_page:
    <span class="external">    </span>print line</PRE></DIV>

        <p>
          Legacy AppEngine 中Python 2.5的代码如使用"with"语句, 需要添加 "from future import with_statement"。
        </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="TODO_Comments" id="TODO_Comments">TODO注释</A></H3>
<SPAN class="link_button" id="link-TODO_Comments__button" name="link-TODO_Comments__button"><A href="?showone=TODO_Comments#TODO_Comments">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('TODO_Comments')" name="TODO_Comments__button" id="TODO_Comments__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        对代码使用 <code>TODO</code>注释只能是临时的，短期的解决方案，足够好但不够完美。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="TODO_Comments__body" id="TODO_Comments__body" style="display: none">
        <p>
          <code>TODO</code>s应该包含一个全部大写的<code>TODO</code>字符串，紧跟着是用括号括起来的你的名字, email地址或其它标识符。
          然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么。
          主要目的是为了有一个统一的<code>TODO</code>格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节)。
          写了<code>TODO</code>注释并不保证写的人会亲自解决问题。当你写了一个<code>TODO</code>, 请注上你的名字。

       </p>
        
        <DIV class=""><PRE># TODO(kl@gmail.com): Use a "*" here for string repetition.
# TODO(Zeke) Change this to use relations.</PRE></DIV>
        <p>
          如果你的<code>TODO</code>是"将来做某事"的形式, 那么请确保你包含了一个指定的日期("2009年11月解决")或者一个特定的事件("等到所有的客户都可以处理XML请求就移除这些代码")。
        </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Imports_formatting" id="Imports_formatting">导入格式</A></H3>
<SPAN class="link_button" id="link-Imports_formatting__button" name="link-Imports_formatting__button"><A href="?showone=Imports_formatting#Imports_formatting">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Imports_formatting')" name="Imports_formatting__button" id="Imports_formatting__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        导入语句应该独占一行。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Imports_formatting__body" id="Imports_formatting__body" style="display: none">
    <p>
      例如:
    </p>

<DIV class=""><PRE>Yes: <span class="external"></span>import os
     <span class="external"></span>import sys</PRE></DIV>
<DIV class=""><PRE class="badcode">No:  <span class="external"></span>import os, sys</PRE></DIV>
    <p>
      导入应该总数放着文件的顶部，仅仅是在模块注释和doc strings之后，在模块全局变量和内容之前。
      导入应该按照最通用到不通用的顺序进行排列分组：
    </p>
    <ul>
      <li>标准库的导入</li>
      <li>第三方库的导入</li>
      
      <li>应用程序特定的库的导入</li>
    </ul>
    <p>
      每个分组中，导入应该按照字母顺序进行排列，忽略大小写，依照每个模块的全路径进行排列。
    </p>
    <DIV class=""><PRE>
<span class="external"></span>import foo
<span class="external"></span>from foo import bar
<span class="external"></span>from foo.bar import baz
<span class="external"></span>from foo.bar import Quux
<span class="external"></span>from Foob import ar</PRE></DIV>
    
    
    
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Statements" id="Statements">语句</A></H3>
<SPAN class="link_button" id="link-Statements__button" name="link-Statements__button"><A href="?showone=Statements#Statements">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Statements')" name="Statements__button" id="Statements__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        通常在一行中只有一条语句。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Statements__body" id="Statements__body" style="display: none">
    <p>
      然而, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行。
      特别说明一点，决不能将<code>try</code>/<code>except</code> 放在一行，因为<code>try</code> 和 <code>except</code>在同一行不能配合使用。
      你只能在没有<code>else</code>的情况下才能将<code>if</code>语句放在一行。
    </p>

    <DIV class=""><PRE>Ye<span class="external"></span>s:

  <span class="external"></span>if foo: bar(foo)</PRE></DIV>
<DIV class=""><PRE class="badcode">No<span class="external"></span>:

  <span class="external"></span>if foo: bar(foo)
  <span class="external"></span>else:   baz(foo)

  <span class="external"></span>try:               bar(foo)
  <span class="external"></span>except ValueError: baz(foo)

  <span class="external"></span>try:
    <span class="external">  </span>bar(foo)
  <span class="external"></span>except ValueError: baz(foo)
<span class="external"></span>
</PRE></DIV>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Access_Control" id="Access_Control">访问控制</A></H3>
<SPAN class="link_button" id="link-Access_Control__button" name="link-Access_Control__button"><A href="?showone=Access_Control#Access_Control">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Access_Control')" name="Access_Control__button" id="Access_Control__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        在Python中，如果一个访问函数是繁琐且不重要的，你应该使用公有变量来替代它，从而避免函数调用时不必要的资源开销。当添加更多功能时，你可以用<code>属性</code>来保持语句的一致性。
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Access_Control__body" id="Access_Control__body" style="display: none">
    <p>
      另一方面，如果访问是非常复杂的，或者访问一个变量的价值具有重要意义，你就应该使用函数调用(遵循<a HREF="#naming">命名</a>指南)的方式，如<code>get_foo()</code>
      和 <code>set_foo()</code>。如果过去的行为允许通过一个属性来访问，就不要绑定一个新的控制器方法到这个属性上。
      这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化。
    </p>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Naming" id="Naming">命名</A></H3>
<SPAN class="link_button" id="link-Naming__button" name="link-Naming__button"><A href="?showone=Naming#Naming">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Naming')" name="Naming__button" id="Naming__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        <code>module_name, package_name, ClassName,
        method_name, ExceptionName,
        function_name, GLOBAL_CONSTANT_NAME,
        global_var_name, instance_var_name, function_parameter_name,
        local_var_name.</code>
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Naming__body" id="Naming__body" style="display: none">
    <P class="">
<SPAN class="stylepoint_subsection">应该避免的名字</SPAN>

    <ul>
      <li>单字符名字，除了计数器或迭代器</li>
      <li>在任何包或模块名中使用破折号(<code>-</code>)</li>
      <li>
        双下划线开头和结尾 <code>__double_leading_and_trailing_underscore__</code> 的名字(Python保留)</li>
    </ul>

    </P>
    <P class="">
<SPAN class="stylepoint_subsection">命名惯例</SPAN>

    <ul>
      <li>
        "Internal"意味着对模块或者protected类或private类来说都是内部的。</li>
      <li>
        用单下划线(<code>_</code>)开头表示模块变量或函数是protected的(使用<code>import * from</code>时不会包含)。
        用双下划线(<code>__</code>)开头的实例变量或方法表示类内私有。
      </li>
      <li>
        将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块。
      </li>
      <li>
        对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py)。
        尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰。
        ("等等 -- 我是否要这样写
        <code>import StringIO</code> 或 <code>from StringIO import
        StringIO</code>?")</li>
    </ul>

    </P>
    <P class="">
<SPAN class="stylepoint_subsection">从Guido的建议衍生出来的指南</SPAN>

    <table rules="all" border="1" cellspacing="2" cellpadding="2">
      
      <tr>
        <th>Type</th>
        <th>Public</th>
        <th>Internal</th>
      </tr>
      

      
      <tr>
        <td>Packages</td>
        <td><code>lower_with_under</code></td>
        <td></td>
      </tr>

      <tr>
        <td>Modules</td>
        <td><code>lower_with_under</code></td>
        <td><code>_lower_with_under</code></td>
      </tr>

      <tr>
        <td>Classes</td>
        <td><code>CapWords</code></td>
        <td><code>_CapWords</code></td>
      </tr>

      <tr>
        <td>Exceptions</td>
        <td><code>CapWords</code></td>
        <td></td>
      </tr>

      

      <tr>
        <td>Functions</td>
        <td><code>lower_with_under()</code></td>
        <td><code>_lower_with_under()</code></td>
      </tr>

      <tr>
        <td>Global/Class Constants</td>
        <td><code>CAPS_WITH_UNDER</code></td>
        <td><code>_CAPS_WITH_UNDER</code></td>
      </tr>

      <tr>
        <td>Global/Class Variables</td>
        <td><code>lower_with_under</code></td>
        <td><code>_lower_with_under</code></td>
      </tr>

      <tr>
        <td>Instance Variables</td>
        <td><code>lower_with_under</code></td>
        <td><code>_lower_with_under (protected) or __lower_with_under (private)</code></td>
      </tr>

      

      <tr>
        <td>Method Names</td>
        <td><code>lower_with_under()</code></td>
        <td><code>_lower_with_under() (protected) or __lower_with_under() (private)</code></td>
      </tr>

      <tr>
        <td>Function/Method Parameters</td>
        <td><code>lower_with_under</code></td>
        <td></td>
      </tr>

      <tr>
        <td>Local Variables</td>
        <td><code>lower_with_under</code></td>
        <td></td>
      </tr>
      

    </table>

    
   </P>
      </DIV></DIV>
    </DIV>
    <DIV class="">
<H3><A name="Main" id="Main">主函数(Main)</A></H3>
<SPAN class="link_button" id="link-Main__button" name="link-Main__button"><A href="?showone=Main#Main">
          link
        </A></SPAN><SPAN class="showhide_button" onclick="javascript:ShowHideByName('Main')" name="Main__button" id="Main__button">▶</SPAN>
      <DIV style="display:inline;" class="">
        即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中. 
      </DIV>
      <DIV class=""><DIV class="stylepoint_body" name="Main__body" id="Main__body" style="display: none">
    <p>
      在Python中，<code>pydoc</code>和单元测试一样，都要求模块是可导入的。你的代码中在执行你的主程序之前总是应该检查<code>if __name__ == '__main__'</code>，
      以便当模块是被导入的时主程序是不能够被执行的。
    </p>
    <DIV class=""><PRE>
<span class="external"></span>def main():
   <span class="external">   </span>...

<span class="external"></span>if __name__ == '__main__':
  <span class="external">  </span>main()
<span class="external"></span>
</PRE></DIV>

    <p>
      在模块被导入时所有的顶级代码将被执行。注意不要调用方法，创建对象或者执行那些不应该在使用<code>pydoc</code>时执行的操作。
    </p>
      </DIV></DIV>
    </DIV>
  </DIV>

<H2>临别赠言</H2>
    <p>
      <em>请保持一致性</em>.
    </p>

    <p>
      如果你正在编写代码，花几分钟看一下你的代码，然后决定它的风格。如果它们在所有的算术操作符两边使用空格，那么你也应该这么做。如果它们的注释都使用码标线包住，请确认你也这么做。
    </p>

    <p>
      制定风格指南的目的是让编码有一个共同的词汇表，这样就可以让其他人关注你讲的是什么，而不是你是如何讲的。
      我们在这里推出一个全局的样式规则就是让人们知道这些词汇表，但是你们自己制定的样式同样重要。
      如果你添加到一个文件中的代码和已经存在的代码风格截然不同，它会让阅读代码的人不知所措，避免这种情况。
    </p>
    <p>
      【重要提示】：本文由英文翻译而来，在翻译的过程中由于英文水平和技术水平的限制，难免会出现不准确或错误。在你阅读本文的时候如果遇到不懂，不理解的情况，请参阅<a href="http://google.github.io/styleguide/pyguide.html">英文版</a>。
          同时，欢迎你指出错误，以便让此文更好，先谢过。
    </p>


<p align="right">
版本 2.59
</p>


<address>
  Amit Patel<br>
  Antoine Picard<br>
  Eugene Jhong<br>
  Gregory P. Smith<br>
  Jeremy Hylton<br>
  Matt Smart<br>
  Mike Shields<br>
  Shane Liebling<br>
</address>
</BODY>
</HTML>
